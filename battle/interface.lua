bt._safe_invoke_shared = {}
bt._safe_invoke_catch_errors = true

--- @brief invoke a script callback in a safe, sandboxed environment
function bt.safe_invoke(instance, callback_id, ...)
    -- setup fenv, done everytime to reset any globals
    local env = {}
    for common in range(
        "pairs",
        "ipairs",
        "values",
        "keys",
        "range",
        "print",
        "println",
        "dbg",

        "sizeof",
        "is_empty",
        "clamp",
        "project",
        "mix",
        "smoothstep",
        "fract",
        "ternary",
        "which",
        "splat",
        "slurp",
        "select",
        "serialize",

        "INFINITY",
        "POSITIVE_INFINITY",
        "NEGATIVE_INFINITY"
    ) do
        assert(_G[common] ~= nil)
        env[common] = _G[common]
    end

    env.rand = rt.rand
    env.random = {}
    env.math = math
    env.table = table
    env.string = string

    -- blacklist
    for no in range(
        "assert",
        "collectgarbage",
        "dofile",
        "error",
        "getmetatable",
        "setmetatable",
        "load",
        "loadfile",
        "require",
        "rawequal",
        "rawget",
        "rawset",
        "setfenv",
        "getfenv"
    ) do
        env[no] = nil
    end

    -- shared environment, not reset between calls
    env._G = bt._safe_invoke_shared

    setmetatable(env, {})
    local metatable = getmetatable(env)
    metatable.__index = function(self, key)
        rt.warning("In bt.safe_invoke: In " .. instance:get_id() .. "." .. callback_id .. ": Error: trying to access `" .. key .. "` which is not part of the sandboxed environment")
        return nil
    end

    metatable.__newindex = function(self, key, value)
        rt.warning("In bt.safe_invoke: In " .. instance:get_id() .. "." .. callback_id .. ": Error: trying to modify sandboxed environment, but it is immutable. Only use `local` variables, or write to the `_G` shared table")
        return nil
    end

    -- safely invoke callback
    local callback = instance[callback_id]
    debug.setfenv(callback, env)
    local res, error_maybe

    if bt._safe_invoke_catch_errors then
        local args = {...}
        res, error_maybe = pcall(function()
            callback(table.unpack(args))
        end)

        if error_maybe ~= nil then
            rt.warning("In bt.safe_invoke: In " .. instance:get_id() .. "." .. callback_id .. ": Error: " .. error_maybe)
        end
    else
        res = callback(...)
    end
    return res
end

--- @class bt.EntityInterface
function bt.EntityInterface(scene, entity)
    local self, metatable = {}, {}
    setmetatable(self, metatable)

    metatable.scene = scene
    metatable.original = entity

    self.set_hp = function(self, new_value)
        local entity = getmetatable(self).original
        local scene = getmetatable(self).scene

        if new_value == 0 then
            scene:kill(entity)
        else
            local difference = entity:get_hp_current() - clamp(new_value, 0, entity:get_hp_base())
            if difference > 0 then
                scene:add_hp(entity, difference)
            else
                scene:reduce_hp(entity, math.abs(difference))
            end
        end
    end

    self.add_hp = function(self, offset)
        local entity = getmetatable(self).original
        local scene = getmetatable(self).scene

        if offset > 0 then
            scene:add_hp(entity, offset)
        elseif offset < 0 then
            scene:reduce_hp(entity, math.abs(offset))
        end
    end

    self.reduce_hp = function(self, offset)
        local entity = getmetatable(self).original
        local scene = getmetatable(self).scene

        if offset < 0 then
            scene:add_hp(entity, offset)
        elseif offset > 0 then
            scene:reduce_hp(entity, math.abs(offset))
        end
    end

    --- @param self bt.EntityInterface
    --- @param id StatusID
    self.add_status = function(self, id)
        local entity = getmetatable(self).original
        local scene = getmetatable(self).scene
        scene:add_status(entity, id)
    end

    -- todo

    self.list_statuses = function(self)
        local entity = getmetatable(self).original
        local scene = getmetatable(self).scene

        local out = {}
        for status in values(entity) do
            table.insert(bt.StatusInterface(scene, entity, status))
        end
        return out
    end

    -- autogenerated forwarding
    for forward in range(
        "get_hp",
        "get_hp_base",
        "get_attack",
        "get_attack_base",
        "get_defense",
        "get_defense_base",
        "get_speed",
        "get_speed_base",
        "get_is_dead",
        "get_is_knocked_out",
        "get_is_alive"
    ) do
        self[forward] = function(self)
            return getmetatable(self).original[forward]()
        end
    end

    -- autogenerated getters
    metatable.getter_mapping = {
        ["hp"] = self.get_hp_current,
        ["hp_current"] = self.get_hp_current,
        ["hp_base"] = self.get_hp_base,
    }

    metatable.__index = function(self, key)
        local getter = getmetatable(self).getter_mapping[key]
        if getter ~= nil then
            return getter(self)
        else
            local out = rawget(self, key)
            if out == nil then
                rt.warning("In bt.EntityInterface:__index: trying to access property `" .. key .. "` of Entity `" .. getmetatable(self).original:get_id() .. "`, but it does not exist")
            end
            return out
        end
    end

    return self
end

--- @class bt.StatusInterface
function bt.StatusInterface(scene, entity, status)
    local self, metatable = {}, {}
    setmetatable(self, metatable)

    metatable.scene = scene
    metatable.entity = entity
    metatable.original = status

    self.get_id = function(self)
        return getmetatable(self).original:get_id()
    end

    self.get_name = function(self)
        return getmetatable(self).original:get_name()
    end

    self.get_max_duration = function(self)
        return getmetatable(self).original:get_max_duration()
    end

    self.get_n_turns_elapsed = function(self)
        return getmetatable(self).original:get_status_n_turns_elapsed(status)
    end

    metatable.getter_mapping = {
        ["id"] = self.get_id,
        ["name"] = self.get_name,
        ["max_duration"] = self.get_max_duration,
        ["n_turns_elapsed"] = self.get_n_turns_elapsed
    }

    for which in range("attack", "defense", "speed") do
        local offset_name = which .. "_offset"
        self["get_" .. offset_name] = function(self)
            return getmetatable(self).original[offset_name]
        end
        metatable.getter_mapping[offset_name] = self["get_" .. offset_name]

        local factor_name = which .. "_factor"
        self["get_" .. factor_name] = function(self)
            return getmetatable(self).original[factor_name]
        end
        metatable.getter_mapping[factor_name] = self["get_" .. factor_name]
    end

    metatable.__index = function(self, key)
        local getter = getmetatable(self).getter_mapping[key]
        if getter ~= nil then
            return getter(self)
        else
            local out = rawget(self, key)
            if out == nil then
                rt.warning("In bt.EntityInterface:__index: trying to access property `" .. key .. "` of Entity `" .. getmetatable(self).entity:get_id() .. "`, but it does not exist")
            end
            return out
        end
    end

    metatable.__newindex = function(self, key, value)
        rt.warning("In bt.StatusInterface:__newindex: trying to set property `" .. key .. "` of Status `" .. getmetatable(self).original:get_id() .. "` to `" .. serialize(value) .. "`, but interface is immutable")
        return
    end
    return self
end